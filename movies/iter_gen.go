// Code generated by modusGraphGen. DO NOT EDIT.

package movies

import (
	"context"
	"iter"
)

// SearchIter returns an iterator over Actor entities matching term.
// It automatically pages through results using Go 1.23+ range-over-func.
func (c *ActorClient) SearchIter(ctx context.Context, term string) iter.Seq2[Actor, error] {
	return func(yield func(Actor, error) bool) {
		offset := 0
		for {
			results, err := c.Search(ctx, term, First(defaultPageSize), Offset(offset))
			if err != nil {
				var zero Actor
				yield(zero, err)
				return
			}
			if len(results) == 0 {
				return
			}
			for _, r := range results {
				if !yield(r, nil) {
					return
				}
			}
			if len(results) < defaultPageSize {
				return
			}
			offset += len(results)
		}
	}
}

// ListIter returns an iterator over all Actor entities.
// It automatically pages through results using Go 1.23+ range-over-func.
func (c *ActorClient) ListIter(ctx context.Context) iter.Seq2[Actor, error] {
	return func(yield func(Actor, error) bool) {
		offset := 0
		for {
			results, err := c.List(ctx, First(defaultPageSize), Offset(offset))
			if err != nil {
				var zero Actor
				yield(zero, err)
				return
			}
			if len(results) == 0 {
				return
			}
			for _, r := range results {
				if !yield(r, nil) {
					return
				}
			}
			if len(results) < defaultPageSize {
				return
			}
			offset += len(results)
		}
	}
}

// SearchIter returns an iterator over ContentRating entities matching term.
// It automatically pages through results using Go 1.23+ range-over-func.
func (c *ContentRatingClient) SearchIter(ctx context.Context, term string) iter.Seq2[ContentRating, error] {
	return func(yield func(ContentRating, error) bool) {
		offset := 0
		for {
			results, err := c.Search(ctx, term, First(defaultPageSize), Offset(offset))
			if err != nil {
				var zero ContentRating
				yield(zero, err)
				return
			}
			if len(results) == 0 {
				return
			}
			for _, r := range results {
				if !yield(r, nil) {
					return
				}
			}
			if len(results) < defaultPageSize {
				return
			}
			offset += len(results)
		}
	}
}

// ListIter returns an iterator over all ContentRating entities.
// It automatically pages through results using Go 1.23+ range-over-func.
func (c *ContentRatingClient) ListIter(ctx context.Context) iter.Seq2[ContentRating, error] {
	return func(yield func(ContentRating, error) bool) {
		offset := 0
		for {
			results, err := c.List(ctx, First(defaultPageSize), Offset(offset))
			if err != nil {
				var zero ContentRating
				yield(zero, err)
				return
			}
			if len(results) == 0 {
				return
			}
			for _, r := range results {
				if !yield(r, nil) {
					return
				}
			}
			if len(results) < defaultPageSize {
				return
			}
			offset += len(results)
		}
	}
}

// SearchIter returns an iterator over Country entities matching term.
// It automatically pages through results using Go 1.23+ range-over-func.
func (c *CountryClient) SearchIter(ctx context.Context, term string) iter.Seq2[Country, error] {
	return func(yield func(Country, error) bool) {
		offset := 0
		for {
			results, err := c.Search(ctx, term, First(defaultPageSize), Offset(offset))
			if err != nil {
				var zero Country
				yield(zero, err)
				return
			}
			if len(results) == 0 {
				return
			}
			for _, r := range results {
				if !yield(r, nil) {
					return
				}
			}
			if len(results) < defaultPageSize {
				return
			}
			offset += len(results)
		}
	}
}

// ListIter returns an iterator over all Country entities.
// It automatically pages through results using Go 1.23+ range-over-func.
func (c *CountryClient) ListIter(ctx context.Context) iter.Seq2[Country, error] {
	return func(yield func(Country, error) bool) {
		offset := 0
		for {
			results, err := c.List(ctx, First(defaultPageSize), Offset(offset))
			if err != nil {
				var zero Country
				yield(zero, err)
				return
			}
			if len(results) == 0 {
				return
			}
			for _, r := range results {
				if !yield(r, nil) {
					return
				}
			}
			if len(results) < defaultPageSize {
				return
			}
			offset += len(results)
		}
	}
}

// SearchIter returns an iterator over Director entities matching term.
// It automatically pages through results using Go 1.23+ range-over-func.
func (c *DirectorClient) SearchIter(ctx context.Context, term string) iter.Seq2[Director, error] {
	return func(yield func(Director, error) bool) {
		offset := 0
		for {
			results, err := c.Search(ctx, term, First(defaultPageSize), Offset(offset))
			if err != nil {
				var zero Director
				yield(zero, err)
				return
			}
			if len(results) == 0 {
				return
			}
			for _, r := range results {
				if !yield(r, nil) {
					return
				}
			}
			if len(results) < defaultPageSize {
				return
			}
			offset += len(results)
		}
	}
}

// ListIter returns an iterator over all Director entities.
// It automatically pages through results using Go 1.23+ range-over-func.
func (c *DirectorClient) ListIter(ctx context.Context) iter.Seq2[Director, error] {
	return func(yield func(Director, error) bool) {
		offset := 0
		for {
			results, err := c.List(ctx, First(defaultPageSize), Offset(offset))
			if err != nil {
				var zero Director
				yield(zero, err)
				return
			}
			if len(results) == 0 {
				return
			}
			for _, r := range results {
				if !yield(r, nil) {
					return
				}
			}
			if len(results) < defaultPageSize {
				return
			}
			offset += len(results)
		}
	}
}

// SearchIter returns an iterator over Film entities matching term.
// It automatically pages through results using Go 1.23+ range-over-func.
func (c *FilmClient) SearchIter(ctx context.Context, term string) iter.Seq2[Film, error] {
	return func(yield func(Film, error) bool) {
		offset := 0
		for {
			results, err := c.Search(ctx, term, First(defaultPageSize), Offset(offset))
			if err != nil {
				var zero Film
				yield(zero, err)
				return
			}
			if len(results) == 0 {
				return
			}
			for _, r := range results {
				if !yield(r, nil) {
					return
				}
			}
			if len(results) < defaultPageSize {
				return
			}
			offset += len(results)
		}
	}
}

// ListIter returns an iterator over all Film entities.
// It automatically pages through results using Go 1.23+ range-over-func.
func (c *FilmClient) ListIter(ctx context.Context) iter.Seq2[Film, error] {
	return func(yield func(Film, error) bool) {
		offset := 0
		for {
			results, err := c.List(ctx, First(defaultPageSize), Offset(offset))
			if err != nil {
				var zero Film
				yield(zero, err)
				return
			}
			if len(results) == 0 {
				return
			}
			for _, r := range results {
				if !yield(r, nil) {
					return
				}
			}
			if len(results) < defaultPageSize {
				return
			}
			offset += len(results)
		}
	}
}

// SearchIter returns an iterator over Genre entities matching term.
// It automatically pages through results using Go 1.23+ range-over-func.
func (c *GenreClient) SearchIter(ctx context.Context, term string) iter.Seq2[Genre, error] {
	return func(yield func(Genre, error) bool) {
		offset := 0
		for {
			results, err := c.Search(ctx, term, First(defaultPageSize), Offset(offset))
			if err != nil {
				var zero Genre
				yield(zero, err)
				return
			}
			if len(results) == 0 {
				return
			}
			for _, r := range results {
				if !yield(r, nil) {
					return
				}
			}
			if len(results) < defaultPageSize {
				return
			}
			offset += len(results)
		}
	}
}

// ListIter returns an iterator over all Genre entities.
// It automatically pages through results using Go 1.23+ range-over-func.
func (c *GenreClient) ListIter(ctx context.Context) iter.Seq2[Genre, error] {
	return func(yield func(Genre, error) bool) {
		offset := 0
		for {
			results, err := c.List(ctx, First(defaultPageSize), Offset(offset))
			if err != nil {
				var zero Genre
				yield(zero, err)
				return
			}
			if len(results) == 0 {
				return
			}
			for _, r := range results {
				if !yield(r, nil) {
					return
				}
			}
			if len(results) < defaultPageSize {
				return
			}
			offset += len(results)
		}
	}
}

// SearchIter returns an iterator over Location entities matching term.
// It automatically pages through results using Go 1.23+ range-over-func.
func (c *LocationClient) SearchIter(ctx context.Context, term string) iter.Seq2[Location, error] {
	return func(yield func(Location, error) bool) {
		offset := 0
		for {
			results, err := c.Search(ctx, term, First(defaultPageSize), Offset(offset))
			if err != nil {
				var zero Location
				yield(zero, err)
				return
			}
			if len(results) == 0 {
				return
			}
			for _, r := range results {
				if !yield(r, nil) {
					return
				}
			}
			if len(results) < defaultPageSize {
				return
			}
			offset += len(results)
		}
	}
}

// ListIter returns an iterator over all Location entities.
// It automatically pages through results using Go 1.23+ range-over-func.
func (c *LocationClient) ListIter(ctx context.Context) iter.Seq2[Location, error] {
	return func(yield func(Location, error) bool) {
		offset := 0
		for {
			results, err := c.List(ctx, First(defaultPageSize), Offset(offset))
			if err != nil {
				var zero Location
				yield(zero, err)
				return
			}
			if len(results) == 0 {
				return
			}
			for _, r := range results {
				if !yield(r, nil) {
					return
				}
			}
			if len(results) < defaultPageSize {
				return
			}
			offset += len(results)
		}
	}
}

// ListIter returns an iterator over all Performance entities.
// It automatically pages through results using Go 1.23+ range-over-func.
func (c *PerformanceClient) ListIter(ctx context.Context) iter.Seq2[Performance, error] {
	return func(yield func(Performance, error) bool) {
		offset := 0
		for {
			results, err := c.List(ctx, First(defaultPageSize), Offset(offset))
			if err != nil {
				var zero Performance
				yield(zero, err)
				return
			}
			if len(results) == 0 {
				return
			}
			for _, r := range results {
				if !yield(r, nil) {
					return
				}
			}
			if len(results) < defaultPageSize {
				return
			}
			offset += len(results)
		}
	}
}

// SearchIter returns an iterator over Rating entities matching term.
// It automatically pages through results using Go 1.23+ range-over-func.
func (c *RatingClient) SearchIter(ctx context.Context, term string) iter.Seq2[Rating, error] {
	return func(yield func(Rating, error) bool) {
		offset := 0
		for {
			results, err := c.Search(ctx, term, First(defaultPageSize), Offset(offset))
			if err != nil {
				var zero Rating
				yield(zero, err)
				return
			}
			if len(results) == 0 {
				return
			}
			for _, r := range results {
				if !yield(r, nil) {
					return
				}
			}
			if len(results) < defaultPageSize {
				return
			}
			offset += len(results)
		}
	}
}

// ListIter returns an iterator over all Rating entities.
// It automatically pages through results using Go 1.23+ range-over-func.
func (c *RatingClient) ListIter(ctx context.Context) iter.Seq2[Rating, error] {
	return func(yield func(Rating, error) bool) {
		offset := 0
		for {
			results, err := c.List(ctx, First(defaultPageSize), Offset(offset))
			if err != nil {
				var zero Rating
				yield(zero, err)
				return
			}
			if len(results) == 0 {
				return
			}
			for _, r := range results {
				if !yield(r, nil) {
					return
				}
			}
			if len(results) < defaultPageSize {
				return
			}
			offset += len(results)
		}
	}
}
