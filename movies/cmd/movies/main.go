// Code generated by modusGraphGen. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"

	"github.com/alecthomas/kong"
	"github.com/matthewmcneely/modusgraph"
	"github.com/mlwelles/modusGraphMoviesProject/movies"
)

// CLI is the root command parsed by Kong.
var CLI struct {
	Addr          string           `help:"Dgraph gRPC address." default:"dgraph://localhost:9080" env:"DGRAPH_ADDR"`
	Actor         ActorCmd         `cmd:"" help:"Manage Actor entities."`
	ContentRating ContentRatingCmd `cmd:"" help:"Manage ContentRating entities."`
	Country       CountryCmd       `cmd:"" help:"Manage Country entities."`
	Director      DirectorCmd      `cmd:"" help:"Manage Director entities."`
	Film          FilmCmd          `cmd:"" help:"Manage Film entities."`
	Genre         GenreCmd         `cmd:"" help:"Manage Genre entities."`
	Location      LocationCmd      `cmd:"" help:"Manage Location entities."`
	Performance   PerformanceCmd   `cmd:"" help:"Manage Performance entities."`
	Rating        RatingCmd        `cmd:"" help:"Manage Rating entities."`
}

// ActorCmd groups subcommands for Actor.
type ActorCmd struct {
	Get    ActorGetCmd    `cmd:"" help:"Get a Actor by UID."`
	List   ActorListCmd   `cmd:"" help:"List Actor entities."`
	Add    ActorAddCmd    `cmd:"" help:"Add a new Actor."`
	Delete ActorDeleteCmd `cmd:"" help:"Delete a Actor by UID."`
	Search ActorSearchCmd `cmd:"" help:"Search Actor by Name."`
}

type ActorGetCmd struct {
	UID string `arg:"" required:"" help:"The UID of the Actor."`
}

func (c *ActorGetCmd) Run(client *movies.Client) error {
	result, err := client.Actor.Get(context.Background(), c.UID)
	if err != nil {
		return err
	}
	return printJSON(result)
}

type ActorListCmd struct {
	First  int `help:"Maximum results to return." default:"10"`
	Offset int `help:"Number of results to skip." default:"0"`
}

func (c *ActorListCmd) Run(client *movies.Client) error {
	results, err := client.Actor.List(context.Background(),
		movies.First(c.First), movies.Offset(c.Offset))
	if err != nil {
		return err
	}
	return printJSON(results)
}

type ActorAddCmd struct {
	Name string `help:"Set Name." name:"name"`
}

func (c *ActorAddCmd) Run(client *movies.Client) error {
	v := &movies.Actor{
		Name: c.Name,
	}
	if err := client.Actor.Add(context.Background(), v); err != nil {
		return err
	}
	return printJSON(v)
}

type ActorDeleteCmd struct {
	UID string `arg:"" required:"" help:"The UID to delete."`
}

func (c *ActorDeleteCmd) Run(client *movies.Client) error {
	return client.Actor.Delete(context.Background(), c.UID)
}

type ActorSearchCmd struct {
	Term   string `arg:"" required:"" help:"The search term."`
	First  int    `help:"Maximum results to return." default:"10"`
	Offset int    `help:"Number of results to skip." default:"0"`
}

func (c *ActorSearchCmd) Run(client *movies.Client) error {
	results, err := client.Actor.Search(context.Background(), c.Term,
		movies.First(c.First), movies.Offset(c.Offset))
	if err != nil {
		return err
	}
	return printJSON(results)
}

// ContentRatingCmd groups subcommands for ContentRating.
type ContentRatingCmd struct {
	Get    ContentRatingGetCmd    `cmd:"" help:"Get a ContentRating by UID."`
	List   ContentRatingListCmd   `cmd:"" help:"List ContentRating entities."`
	Add    ContentRatingAddCmd    `cmd:"" help:"Add a new ContentRating."`
	Delete ContentRatingDeleteCmd `cmd:"" help:"Delete a ContentRating by UID."`
	Search ContentRatingSearchCmd `cmd:"" help:"Search ContentRating by Name."`
}

type ContentRatingGetCmd struct {
	UID string `arg:"" required:"" help:"The UID of the ContentRating."`
}

func (c *ContentRatingGetCmd) Run(client *movies.Client) error {
	result, err := client.ContentRating.Get(context.Background(), c.UID)
	if err != nil {
		return err
	}
	return printJSON(result)
}

type ContentRatingListCmd struct {
	First  int `help:"Maximum results to return." default:"10"`
	Offset int `help:"Number of results to skip." default:"0"`
}

func (c *ContentRatingListCmd) Run(client *movies.Client) error {
	results, err := client.ContentRating.List(context.Background(),
		movies.First(c.First), movies.Offset(c.Offset))
	if err != nil {
		return err
	}
	return printJSON(results)
}

type ContentRatingAddCmd struct {
	Name string `help:"Set Name." name:"name"`
}

func (c *ContentRatingAddCmd) Run(client *movies.Client) error {
	v := &movies.ContentRating{
		Name: c.Name,
	}
	if err := client.ContentRating.Add(context.Background(), v); err != nil {
		return err
	}
	return printJSON(v)
}

type ContentRatingDeleteCmd struct {
	UID string `arg:"" required:"" help:"The UID to delete."`
}

func (c *ContentRatingDeleteCmd) Run(client *movies.Client) error {
	return client.ContentRating.Delete(context.Background(), c.UID)
}

type ContentRatingSearchCmd struct {
	Term   string `arg:"" required:"" help:"The search term."`
	First  int    `help:"Maximum results to return." default:"10"`
	Offset int    `help:"Number of results to skip." default:"0"`
}

func (c *ContentRatingSearchCmd) Run(client *movies.Client) error {
	results, err := client.ContentRating.Search(context.Background(), c.Term,
		movies.First(c.First), movies.Offset(c.Offset))
	if err != nil {
		return err
	}
	return printJSON(results)
}

// CountryCmd groups subcommands for Country.
type CountryCmd struct {
	Get    CountryGetCmd    `cmd:"" help:"Get a Country by UID."`
	List   CountryListCmd   `cmd:"" help:"List Country entities."`
	Add    CountryAddCmd    `cmd:"" help:"Add a new Country."`
	Delete CountryDeleteCmd `cmd:"" help:"Delete a Country by UID."`
	Search CountrySearchCmd `cmd:"" help:"Search Country by Name."`
}

type CountryGetCmd struct {
	UID string `arg:"" required:"" help:"The UID of the Country."`
}

func (c *CountryGetCmd) Run(client *movies.Client) error {
	result, err := client.Country.Get(context.Background(), c.UID)
	if err != nil {
		return err
	}
	return printJSON(result)
}

type CountryListCmd struct {
	First  int `help:"Maximum results to return." default:"10"`
	Offset int `help:"Number of results to skip." default:"0"`
}

func (c *CountryListCmd) Run(client *movies.Client) error {
	results, err := client.Country.List(context.Background(),
		movies.First(c.First), movies.Offset(c.Offset))
	if err != nil {
		return err
	}
	return printJSON(results)
}

type CountryAddCmd struct {
	Name string `help:"Set Name." name:"name"`
}

func (c *CountryAddCmd) Run(client *movies.Client) error {
	v := &movies.Country{
		Name: c.Name,
	}
	if err := client.Country.Add(context.Background(), v); err != nil {
		return err
	}
	return printJSON(v)
}

type CountryDeleteCmd struct {
	UID string `arg:"" required:"" help:"The UID to delete."`
}

func (c *CountryDeleteCmd) Run(client *movies.Client) error {
	return client.Country.Delete(context.Background(), c.UID)
}

type CountrySearchCmd struct {
	Term   string `arg:"" required:"" help:"The search term."`
	First  int    `help:"Maximum results to return." default:"10"`
	Offset int    `help:"Number of results to skip." default:"0"`
}

func (c *CountrySearchCmd) Run(client *movies.Client) error {
	results, err := client.Country.Search(context.Background(), c.Term,
		movies.First(c.First), movies.Offset(c.Offset))
	if err != nil {
		return err
	}
	return printJSON(results)
}

// DirectorCmd groups subcommands for Director.
type DirectorCmd struct {
	Get    DirectorGetCmd    `cmd:"" help:"Get a Director by UID."`
	List   DirectorListCmd   `cmd:"" help:"List Director entities."`
	Add    DirectorAddCmd    `cmd:"" help:"Add a new Director."`
	Delete DirectorDeleteCmd `cmd:"" help:"Delete a Director by UID."`
	Search DirectorSearchCmd `cmd:"" help:"Search Director by Name."`
}

type DirectorGetCmd struct {
	UID string `arg:"" required:"" help:"The UID of the Director."`
}

func (c *DirectorGetCmd) Run(client *movies.Client) error {
	result, err := client.Director.Get(context.Background(), c.UID)
	if err != nil {
		return err
	}
	return printJSON(result)
}

type DirectorListCmd struct {
	First  int `help:"Maximum results to return." default:"10"`
	Offset int `help:"Number of results to skip." default:"0"`
}

func (c *DirectorListCmd) Run(client *movies.Client) error {
	results, err := client.Director.List(context.Background(),
		movies.First(c.First), movies.Offset(c.Offset))
	if err != nil {
		return err
	}
	return printJSON(results)
}

type DirectorAddCmd struct {
	Name string `help:"Set Name." name:"name"`
}

func (c *DirectorAddCmd) Run(client *movies.Client) error {
	v := &movies.Director{
		Name: c.Name,
	}
	if err := client.Director.Add(context.Background(), v); err != nil {
		return err
	}
	return printJSON(v)
}

type DirectorDeleteCmd struct {
	UID string `arg:"" required:"" help:"The UID to delete."`
}

func (c *DirectorDeleteCmd) Run(client *movies.Client) error {
	return client.Director.Delete(context.Background(), c.UID)
}

type DirectorSearchCmd struct {
	Term   string `arg:"" required:"" help:"The search term."`
	First  int    `help:"Maximum results to return." default:"10"`
	Offset int    `help:"Number of results to skip." default:"0"`
}

func (c *DirectorSearchCmd) Run(client *movies.Client) error {
	results, err := client.Director.Search(context.Background(), c.Term,
		movies.First(c.First), movies.Offset(c.Offset))
	if err != nil {
		return err
	}
	return printJSON(results)
}

// FilmCmd groups subcommands for Film.
type FilmCmd struct {
	Get    FilmGetCmd    `cmd:"" help:"Get a Film by UID."`
	List   FilmListCmd   `cmd:"" help:"List Film entities."`
	Add    FilmAddCmd    `cmd:"" help:"Add a new Film."`
	Delete FilmDeleteCmd `cmd:"" help:"Delete a Film by UID."`
	Search FilmSearchCmd `cmd:"" help:"Search Film by Name."`
}

type FilmGetCmd struct {
	UID string `arg:"" required:"" help:"The UID of the Film."`
}

func (c *FilmGetCmd) Run(client *movies.Client) error {
	result, err := client.Film.Get(context.Background(), c.UID)
	if err != nil {
		return err
	}
	return printJSON(result)
}

type FilmListCmd struct {
	First  int `help:"Maximum results to return." default:"10"`
	Offset int `help:"Number of results to skip." default:"0"`
}

func (c *FilmListCmd) Run(client *movies.Client) error {
	results, err := client.Film.List(context.Background(),
		movies.First(c.First), movies.Offset(c.Offset))
	if err != nil {
		return err
	}
	return printJSON(results)
}

type FilmAddCmd struct {
	Name               string `help:"Set Name." name:"name"`
	InitialReleaseDate string `help:"Set InitialReleaseDate." name:"initialreleasedate"`
	Tagline            string `help:"Set Tagline." name:"tagline"`
}

func (c *FilmAddCmd) Run(client *movies.Client) error {
	v := &movies.Film{
		Name:    c.Name,
		Tagline: c.Tagline,
	}
	if err := client.Film.Add(context.Background(), v); err != nil {
		return err
	}
	return printJSON(v)
}

type FilmDeleteCmd struct {
	UID string `arg:"" required:"" help:"The UID to delete."`
}

func (c *FilmDeleteCmd) Run(client *movies.Client) error {
	return client.Film.Delete(context.Background(), c.UID)
}

type FilmSearchCmd struct {
	Term   string `arg:"" required:"" help:"The search term."`
	First  int    `help:"Maximum results to return." default:"10"`
	Offset int    `help:"Number of results to skip." default:"0"`
}

func (c *FilmSearchCmd) Run(client *movies.Client) error {
	results, err := client.Film.Search(context.Background(), c.Term,
		movies.First(c.First), movies.Offset(c.Offset))
	if err != nil {
		return err
	}
	return printJSON(results)
}

// GenreCmd groups subcommands for Genre.
type GenreCmd struct {
	Get    GenreGetCmd    `cmd:"" help:"Get a Genre by UID."`
	List   GenreListCmd   `cmd:"" help:"List Genre entities."`
	Add    GenreAddCmd    `cmd:"" help:"Add a new Genre."`
	Delete GenreDeleteCmd `cmd:"" help:"Delete a Genre by UID."`
	Search GenreSearchCmd `cmd:"" help:"Search Genre by Name."`
}

type GenreGetCmd struct {
	UID string `arg:"" required:"" help:"The UID of the Genre."`
}

func (c *GenreGetCmd) Run(client *movies.Client) error {
	result, err := client.Genre.Get(context.Background(), c.UID)
	if err != nil {
		return err
	}
	return printJSON(result)
}

type GenreListCmd struct {
	First  int `help:"Maximum results to return." default:"10"`
	Offset int `help:"Number of results to skip." default:"0"`
}

func (c *GenreListCmd) Run(client *movies.Client) error {
	results, err := client.Genre.List(context.Background(),
		movies.First(c.First), movies.Offset(c.Offset))
	if err != nil {
		return err
	}
	return printJSON(results)
}

type GenreAddCmd struct {
	Name string `help:"Set Name." name:"name"`
}

func (c *GenreAddCmd) Run(client *movies.Client) error {
	v := &movies.Genre{
		Name: c.Name,
	}
	if err := client.Genre.Add(context.Background(), v); err != nil {
		return err
	}
	return printJSON(v)
}

type GenreDeleteCmd struct {
	UID string `arg:"" required:"" help:"The UID to delete."`
}

func (c *GenreDeleteCmd) Run(client *movies.Client) error {
	return client.Genre.Delete(context.Background(), c.UID)
}

type GenreSearchCmd struct {
	Term   string `arg:"" required:"" help:"The search term."`
	First  int    `help:"Maximum results to return." default:"10"`
	Offset int    `help:"Number of results to skip." default:"0"`
}

func (c *GenreSearchCmd) Run(client *movies.Client) error {
	results, err := client.Genre.Search(context.Background(), c.Term,
		movies.First(c.First), movies.Offset(c.Offset))
	if err != nil {
		return err
	}
	return printJSON(results)
}

// LocationCmd groups subcommands for Location.
type LocationCmd struct {
	Get    LocationGetCmd    `cmd:"" help:"Get a Location by UID."`
	List   LocationListCmd   `cmd:"" help:"List Location entities."`
	Add    LocationAddCmd    `cmd:"" help:"Add a new Location."`
	Delete LocationDeleteCmd `cmd:"" help:"Delete a Location by UID."`
	Search LocationSearchCmd `cmd:"" help:"Search Location by Name."`
}

type LocationGetCmd struct {
	UID string `arg:"" required:"" help:"The UID of the Location."`
}

func (c *LocationGetCmd) Run(client *movies.Client) error {
	result, err := client.Location.Get(context.Background(), c.UID)
	if err != nil {
		return err
	}
	return printJSON(result)
}

type LocationListCmd struct {
	First  int `help:"Maximum results to return." default:"10"`
	Offset int `help:"Number of results to skip." default:"0"`
}

func (c *LocationListCmd) Run(client *movies.Client) error {
	results, err := client.Location.List(context.Background(),
		movies.First(c.First), movies.Offset(c.Offset))
	if err != nil {
		return err
	}
	return printJSON(results)
}

type LocationAddCmd struct {
	Name  string `help:"Set Name." name:"name"`
	Loc   string `help:"Set Loc." name:"loc"`
	Email string `help:"Set Email." name:"email"`
}

func (c *LocationAddCmd) Run(client *movies.Client) error {
	v := &movies.Location{
		Name:  c.Name,
		Email: c.Email,
	}
	if err := client.Location.Add(context.Background(), v); err != nil {
		return err
	}
	return printJSON(v)
}

type LocationDeleteCmd struct {
	UID string `arg:"" required:"" help:"The UID to delete."`
}

func (c *LocationDeleteCmd) Run(client *movies.Client) error {
	return client.Location.Delete(context.Background(), c.UID)
}

type LocationSearchCmd struct {
	Term   string `arg:"" required:"" help:"The search term."`
	First  int    `help:"Maximum results to return." default:"10"`
	Offset int    `help:"Number of results to skip." default:"0"`
}

func (c *LocationSearchCmd) Run(client *movies.Client) error {
	results, err := client.Location.Search(context.Background(), c.Term,
		movies.First(c.First), movies.Offset(c.Offset))
	if err != nil {
		return err
	}
	return printJSON(results)
}

// PerformanceCmd groups subcommands for Performance.
type PerformanceCmd struct {
	Get    PerformanceGetCmd    `cmd:"" help:"Get a Performance by UID."`
	List   PerformanceListCmd   `cmd:"" help:"List Performance entities."`
	Add    PerformanceAddCmd    `cmd:"" help:"Add a new Performance."`
	Delete PerformanceDeleteCmd `cmd:"" help:"Delete a Performance by UID."`
}

type PerformanceGetCmd struct {
	UID string `arg:"" required:"" help:"The UID of the Performance."`
}

func (c *PerformanceGetCmd) Run(client *movies.Client) error {
	result, err := client.Performance.Get(context.Background(), c.UID)
	if err != nil {
		return err
	}
	return printJSON(result)
}

type PerformanceListCmd struct {
	First  int `help:"Maximum results to return." default:"10"`
	Offset int `help:"Number of results to skip." default:"0"`
}

func (c *PerformanceListCmd) Run(client *movies.Client) error {
	results, err := client.Performance.List(context.Background(),
		movies.First(c.First), movies.Offset(c.Offset))
	if err != nil {
		return err
	}
	return printJSON(results)
}

type PerformanceAddCmd struct {
	CharacterNote string `help:"Set CharacterNote." name:"characternote"`
}

func (c *PerformanceAddCmd) Run(client *movies.Client) error {
	v := &movies.Performance{
		CharacterNote: c.CharacterNote,
	}
	if err := client.Performance.Add(context.Background(), v); err != nil {
		return err
	}
	return printJSON(v)
}

type PerformanceDeleteCmd struct {
	UID string `arg:"" required:"" help:"The UID to delete."`
}

func (c *PerformanceDeleteCmd) Run(client *movies.Client) error {
	return client.Performance.Delete(context.Background(), c.UID)
}

// RatingCmd groups subcommands for Rating.
type RatingCmd struct {
	Get    RatingGetCmd    `cmd:"" help:"Get a Rating by UID."`
	List   RatingListCmd   `cmd:"" help:"List Rating entities."`
	Add    RatingAddCmd    `cmd:"" help:"Add a new Rating."`
	Delete RatingDeleteCmd `cmd:"" help:"Delete a Rating by UID."`
	Search RatingSearchCmd `cmd:"" help:"Search Rating by Name."`
}

type RatingGetCmd struct {
	UID string `arg:"" required:"" help:"The UID of the Rating."`
}

func (c *RatingGetCmd) Run(client *movies.Client) error {
	result, err := client.Rating.Get(context.Background(), c.UID)
	if err != nil {
		return err
	}
	return printJSON(result)
}

type RatingListCmd struct {
	First  int `help:"Maximum results to return." default:"10"`
	Offset int `help:"Number of results to skip." default:"0"`
}

func (c *RatingListCmd) Run(client *movies.Client) error {
	results, err := client.Rating.List(context.Background(),
		movies.First(c.First), movies.Offset(c.Offset))
	if err != nil {
		return err
	}
	return printJSON(results)
}

type RatingAddCmd struct {
	Name string `help:"Set Name." name:"name"`
}

func (c *RatingAddCmd) Run(client *movies.Client) error {
	v := &movies.Rating{
		Name: c.Name,
	}
	if err := client.Rating.Add(context.Background(), v); err != nil {
		return err
	}
	return printJSON(v)
}

type RatingDeleteCmd struct {
	UID string `arg:"" required:"" help:"The UID to delete."`
}

func (c *RatingDeleteCmd) Run(client *movies.Client) error {
	return client.Rating.Delete(context.Background(), c.UID)
}

type RatingSearchCmd struct {
	Term   string `arg:"" required:"" help:"The search term."`
	First  int    `help:"Maximum results to return." default:"10"`
	Offset int    `help:"Number of results to skip." default:"0"`
}

func (c *RatingSearchCmd) Run(client *movies.Client) error {
	results, err := client.Rating.Search(context.Background(), c.Term,
		movies.First(c.First), movies.Offset(c.Offset))
	if err != nil {
		return err
	}
	return printJSON(results)
}

func printJSON(v any) error {
	enc := json.NewEncoder(os.Stdout)
	enc.SetIndent("", "  ")
	return enc.Encode(v)
}

func main() {
	ctx := kong.Parse(&CLI,
		kong.Name("movies"),
		kong.Description("CLI for the movies data model."),
	)

	client, err := movies.New(CLI.Addr, modusgraph.WithAutoSchema(true))
	if err != nil {
		fmt.Fprintf(os.Stderr, "connect: %v\n", err)
		os.Exit(1)
	}
	defer client.Close()

	err = ctx.Run(client)
	ctx.FatalIfErrorf(err)
}
